# 手写数字识别 Android 应用

这是一个功能完整的手写数字识别应用，主要以 **本地 TensorFlow Lite (TFLite)** 模型为核心进行离线推理（远端服务视为黑盒，仅作为可选项）。本 README 聚焦项目功能、关键技术点、预处理一致性、常见问题与排查建议，方便开发与调试。

## 概览

- 项目：DigitRecognizer（Android）
- 目标：通过本地 TFLite 模型识别手写数字（0-9），支持手写板、拍照和相册三种输入方式
- 特色：离线推理、低延迟；强调与训练/服务器端预处理保持完全一致（尤其是缩放与二值化）以保证识别精度

## 功能特性

- 本地 TFLite 模型离线推理（首要）
- 可选远端 API（作为黑盒调用）
- 输入方式：手写画布（DrawingView）、相机拍照、相册选择
- 显示结果：识别数字、置信度、10 类概率分布

## 快速开始（仅本地模型）

1. 将本地 TFLite 模型放到：

```
app/src/main/assets/digit_recognition_model.tflite
```

2. 构建与安装（在项目根目录运行或在 Android Studio 中运行）：

```
./gradlew clean
./gradlew build
./gradlew installDebug
```

3. 运行应用，选择「本地模型」并通过手写/拍照/相册输入图片进行识别。

## 模型要求（重要）

- 格式：TensorFlow Lite (.tflite)
- 输入：28×28 像素，单通道（灰度）图像（模型可能要求形状为 [1,28,28,1]）
- 数据类型：float32（归一化到 [0,1]）或 uint8（量化），请确认你使用的模型类型
- 输出：10 个类的概率（数字 0-9）

> 一定要确认模型的输入形状与量化信息（float / uint8），不一致会导致推理错误或正确率下降。

## 图像预处理（必须严格和服务器/训练端一致）

预处理的微小差异（尤其是缩放插值与通道/颜色顺序）会显著影响结果。以下为本项目推荐的预处理流程（与训练/服务器端保持一致时识别效果最佳）：

1. 读取原始图像（来自手写画布/相机/相册）为 Bitmap
2. 转为灰度（single channel）
3. 二值化（可选）：可在缩放前或缩放后进行，推荐阈值示例：220（取决于图像亮度）
4. 反色（如训练集为白底黑字而当前为黑底白字需反转）
5. 高质量缩放到 28×28：**使用 Lanczos 插值（与 PIL 的 LANCZOS 等价）**，这能在缩小图像时保持线条的连续性和平滑边缘，避免“虚线/断笔”问题
6. 归一化：若模型为 float32，将像素值映射到 [0,1]；若为 uint8，按模型要求转换
7. 转换为 ByteBuffer 或张量并传入 TFLite Interpreter

为什么要用 Lanczos？
- Lanczos 是适合图像缩小的高质量插值，能用周围多个像素做加权平均，保留线条连续性和灰度过渡；如果使用最近邻或低质量缩放，会导致边缘锯齿或断裂，从而极大影响识别结果。

在 Android 上实现高质量缩放的建议：
- 推荐使用 OpenCV Android（Imgproc.resize + INTER_LANCZOS4）来保证与服务器端 PIL.LANCZOS 的行为更接近
- 如果不想引入 OpenCV，也可使用高质量的第三方图片处理库或确保缩放时使用带滤镜的插值（但要验证和服务器端的数值一致性）

## 已实现的（和已移除的）行为

- 已移除多余的临时文件保存逻辑：常规推理路径不会把中间图像保存到磁盘，所有预处理与 ByteBuffer 转换均在内存完成以提升性能并减少权限/清理负担
- 在调试模式下，可临时开启“保存中间图像”选项以便人工对比（建议仅在本地调试使用，默认关闭）

## 项目结构（重要文件）

```
app/src/main/java/com/dsa/digitrecognizer/
├── MainActivity.kt           # 主入口（UI 容器）
├── MainScreen.kt             # 主界面 UI 与交互逻辑
├── MainViewModel.kt          # 业务逻辑、模型调用协调
├── DrawingView.kt            # 手写画布组件（注意连续笔触处理）
├── LocalModelPredictor.kt    # 本地模型加载与推理封装（TFLite）
├── ImageUtils.kt             # 图像预处理工具（缩放/灰度/二值化/反色/转换 ByteBuffer）
└── ApiService.kt             # 远端 API 客户端（远端视为黑盒，可选使用）
```

## 常见问题与排查建议（调试清单）

1. “模型未初始化” / Operator 不匹配（Model not initialized / Didn't find op）
   - 原因：TFLite 模型使用了高版本或自定义运算符，而应用打包的 TFLite 运行时不支持该 op 或版本。常见于模型转换/量化时引入新 op。
   - 解决：使用与模型转换时相同或更高版本的 TensorFlow Lite 运行时；或重新导出/转换模型以避免不兼容的 op（或禁用/替换不兼容 op）。

2. 识别结果与服务器不一致（偏差较大）
   - 排查点：预处理是否严格一致（尤其是缩放插值、灰度化、反色与归一化顺序）
   - 操作建议：在 Android 与服务器端都导出“最终传入模型的 28x28 数组”（例如 CSV 或二进制），逐像素对比，定位差异在哪个步骤产生

3. 图像变成“虚线”或笔画不连续
   - 常见原因：使用了低质量/错误的缩放插值（例如最近邻），或者缩放前做了二值化导致连续线条被破坏
   - 建议：先在原始彩色/灰度图上用 Lanczos 缩放，再在缩放后做二值化（如果需要）。不要在缩放前二值化为纯黑白再缩放（会引起虚线）

4. 从相册拿到的图片是彩色/复杂背景
   - 建议先做裁剪/透视校正（可选），然后转灰度、增强对比（如自适应阈值或固定阈值 220），最后按缩放流程处理

5. 画布（DrawingView）问题：笔迹每次只保留一笔或先画的笔消失
   - 排查：DrawingView 的路径（Path）状态是否在每次触摸结束被清除或重置，或者在重绘时只绘制当前路径
   - 建议：确保使用一个累计的路径列表来保存历史笔画并在 onDraw 中全部绘制，只有在用户点击“清除”时才清空

6. 看不到缓存/调试图片（例如 `/data/user/.../cache/`）
   - 说明：安卓应用私有目录在非 root 设备上不可直接通过文件管理器访问。可通过 `adb` 或 Android Studio Device File Explorer（模拟器或已 root 设备）来查看

## 调试建议（具体步骤）

- 步骤 A：在 Android 端开启临时调试模式（仅本地）以保存以下文件到缓存：原图、灰度图、缩放后 28x28 图、模型输入张量（方便对比）。
- 步骤 B：在服务器端（如果可访问）对相同原始图片运行预处理并导出相应的 28x28 数组。
- 步骤 C：逐像素对比 Android 与服务器导出的数组（可用脚本或 Excel）定位差异步骤。
- 步骤 D：若差异来自缩放，请在 Android 使用 OpenCV 的 INTER_LANCZOS4 做缩放并重测。

## 关键技术点（适合学习/复现）

- 图像预处理与插值算法（Lanczos）对模型表现的影响
- TFLite 模型的输入/量化/兼容性问题与运行时选择
- 在 Android 上做高质量图像处理（OpenCV 集成）
- 手写画布实现要点：多路径累积、平滑采样、触摸事件节流
- 性能优化：在后台线程加载与执行 Interpreter；考虑 NNAPI/GPU Delegate
- 可复现性：如何使本地推理与训练/服务器端保持一致（导出中间张量做对比）

## 常见日志与含义（示例）

- TensorFlow Lite op 不匹配："Didn't find op for builtin opcode 'FULLY_CONNECTED' version '12'" → 说明运行时不支持该 op 版本
- 图像统计日志：`avgGray=247, 暗色像素(<220)=2107/51788` → 用于判断图像是否为浅色背景/深色笔迹
- 保存的调试图路径：默认调试情况下会写入应用缓存目录，生产环境默认关闭

## 未来改进（候选项）

- 在 DrawingView 中加入压力/速度感知（模拟笔宽）并做平滑处理
- 增加自适应二值化（如 Otsu 或局部阈值）以提高对复杂照片的鲁棒性
- 集成 OpenCV 做高质量缩放与透视矫正
- 添加模型热插拔与在线更新机制（仅限模型文件替换）

## 许可证与来源

- 本项目代码用于学习与演示，请在商用或分发前确认模型与第三方库的许可证

---

如果你希望我把 README 翻译成英文、增加截图、或直接把临时调试功能（开关）从代码里实现并添加到 README 的“如何开启调试”一节，我可以接着修改并在代码中实现该开关（并运行基本验证）。
